stages:
  - security
  - validate
  - plan
  - cost
  - approve
  - apply

# Workflow rules - only run on merge requests
workflow:
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always
    - if: $CI_COMMIT_BRANCH == "master"
      when: always
    - when: never

# Include external CI/CD configuration files
include:
  - local: '.gitlab/ci/security.yml'

variables:
  TF_ROOT: ${CI_PROJECT_DIR}/aws/environments
  AWS_DEFAULT_REGION: us-east-1
  TF_IN_AUTOMATION: "true"
  # Required CI/CD Variables:
  # - AWS_ROLE_ARN: GitLab Runner IAM Role ARN
  # - DEV_DEPLOY_ROLE_ARN: Dev deployment role ARN (optional)
  # - PROD_DEPLOY_ROLE_ARN: Prod deployment role ARN (optional)
  # - GITLAB_TOKEN: For posting MR comments (optional)
  # - INFRACOST_API_KEY: For cost estimation (optional)

.aws_auth_script: &aws_auth_script
  - apk add --no-cache aws-cli jq
  - >
    aws_sts_output=$(aws sts assume-role-with-web-identity
    --role-arn ${AWS_ROLE_ARN}
    --role-session-name "GitLabRunner-${CI_PROJECT_ID}-${CI_PIPELINE_ID}"
    --web-identity-token ${GITLAB_OIDC_TOKEN}
    --duration-seconds 3600
    --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]'
    --output text)
  - export $(printf "AWS_ACCESS_KEY_ID=%s AWS_SECRET_ACCESS_KEY=%s AWS_SESSION_TOKEN=%s" $aws_sts_output)

.terraform:
  image:
    name: hashicorp/terraform:latest
    entrypoint: [""]
  cache:
    key: "${CI_COMMIT_REF_SLUG}-${ENV_DIR}"
    paths:
      - ${TF_ROOT}/${ENV_DIR}/.terraform/
      - ${TF_ROOT}/${ENV_DIR}/.terraform.lock.hcl
  id_tokens:
    GITLAB_OIDC_TOKEN:
      aud: https://gitlab.com
  before_script:
    - *aws_auth_script
    - cd ${TF_ROOT}/${ENV_DIR}
    - |
      if [ -f backend.conf ]; then
        terraform init -backend-config=backend.conf
      else
        terraform init
      fi

# Template for jobs that need to assume environment-specific deployment roles
.assume_deploy_role:
  image:
    name: hashicorp/terraform:latest
    entrypoint: [""]
  cache:
    key: "${CI_COMMIT_REF_SLUG}-${ENV_DIR}"
    paths:
      - ${TF_ROOT}/${ENV_DIR}/.terraform/
      - ${TF_ROOT}/${ENV_DIR}/.terraform.lock.hcl
  id_tokens:
    GITLAB_OIDC_TOKEN:
      aud: https://gitlab.com
  before_script:
    - *aws_auth_script
    # Step 2: Assume environment-specific deployment role
    - |
      if [ -n "$DEPLOY_ROLE_ARN" ]; then
        echo "Assuming deployment role: $DEPLOY_ROLE_ARN"
        deploy_creds=$(aws sts assume-role \
          --role-arn $DEPLOY_ROLE_ARN \
          --role-session-name "Deploy-${ENV_DIR}-${CI_PIPELINE_ID}" \
          --duration-seconds 3600 \
          --query 'Credentials.[AccessKeyId,SecretAccessKey,SessionToken]' \
          --output text)
        export $(printf "AWS_ACCESS_KEY_ID=%s AWS_SECRET_ACCESS_KEY=%s AWS_SESSION_TOKEN=%s" $deploy_creds)
      fi
    - cd ${TF_ROOT}/${ENV_DIR}
    - |
      if [ -f backend.conf ]; then
        terraform init -backend-config=backend.conf
      else
        terraform init
      fi
# Validation Stage

fmt:
  extends: .terraform
  stage: validate
  script:
    - terraform fmt -check -recursive
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: never
  parallel:
    matrix:
      - ENV_DIR: [shared-account, dev-app-account, prod-app-account]

lint:
  stage: validate
  image: ghcr.io/terraform-linters/tflint
  script:
    - cd ${TF_ROOT}/${ENV_DIR}
    - tflint --recursive
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

validate:
  extends: .terraform
  stage: validate
  needs: [fmt, lint]
  script:
    - terraform validate
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: never
  parallel:
    matrix:
      - ENV_DIR: [shared-account, dev-app-account, prod-app-account]


# Plan Stage
.plan:
  extends: .terraform
  stage: plan
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: never
  script:
    - terraform plan -out=tfplan | tee plan.txt
    - terraform show -no-color tfplan > plan-readable.txt
  after_script:
    - |
      if [ "$CI_PIPELINE_SOURCE" == "merge_request_event" ] && [ -n "$GITLAB_TOKEN" ]; then
        cd ${TF_ROOT}/${ENV_DIR}
        PLAN_SUMMARY=$(cat plan-readable.txt | head -100)
        curl --request POST \
          --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
          --data "body=### Terraform Plan: ${ENV_DIR}\n\`\`\`\n${PLAN_SUMMARY}\n\`\`\`" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes" || true
      fi
  artifacts:
    paths:
      - aws/environments/*/tfplan
      - aws/environments/*/plan-readable.txt
    expire_in: 7 days

# Cost Estimation Stage
# Note: Infracost requires INFRACOST_API_KEY to be set in CI/CD variables
# Cost estimation is REQUIRED for production - prevents surprise bills
infracost:
  stage: cost
  image:
    name: infracost/infracost:latest
    entrypoint: [""]
  parallel:
    matrix:
      - ENV_DIR: [shared-account, dev-app-account, prod-app-account]
  script:
    - cd ${TF_ROOT}/${ENV_DIR}
    - infracost breakdown --path . --format json --out-file infracost.json
  artifacts:
    paths:
      - aws/environments/*/infracost.json
    expire_in: 30 days
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
  allow_failure: false

# Approval Stage (runs on master only)
.approve:
  stage: approve
  script:
    - echo "Reviewing plan for ${ENV_DIR}"
    - cd ${TF_ROOT}/${ENV_DIR}
    - cat plan-readable.txt || echo "No plan file found"
  rules:
    - if: $CI_COMMIT_BRANCH == "master"

# Apply Stage (runs on master only after approval)
.apply:
  extends: .assume_deploy_role
  stage: apply
  script:
    - terraform apply -auto-approve tfplan
  rules:
    - if: $CI_COMMIT_BRANCH == "master"
      when: manual

# Shared Account Jobs
shared-plan:
  extends: .plan
  variables:
    ENV_DIR: shared-account

shared-approve:
  extends: .approve
  variables:
    ENV_DIR: shared-account
  needs:
    - job: shared-plan
      artifacts: true
  dependencies:
    - shared-plan

shared-apply:
  extends: .apply
  variables:
    ENV_DIR: shared-account
  environment:
    name: shared-account
    action: start
  needs:
    - job: shared-plan
      artifacts: true
    - job: shared-approve
      artifacts: true
  dependencies:
    - shared-plan

# Dev Account Jobs - Uses role assumption
dev-plan:
  extends: .assume_deploy_role
  stage: plan
  variables:
    ENV_DIR: dev-app-account
    DEPLOY_ROLE_ARN: $DEV_DEPLOY_ROLE_ARN
  script:
    - terraform plan -out=tfplan | tee plan.txt
    - terraform show -no-color tfplan > plan-readable.txt
  after_script:
    - |
      if [ "$CI_PIPELINE_SOURCE" == "merge_request_event" ] && [ -n "$GITLAB_TOKEN" ]; then
        cd ${TF_ROOT}/${ENV_DIR}
        PLAN_SUMMARY=$(cat plan-readable.txt | head -100)
        curl --request POST \
          --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
          --data "body=### Terraform Plan: ${ENV_DIR}\n\`\`\`\n${PLAN_SUMMARY}\n\`\`\`" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes" || true
      fi
  artifacts:
    paths:
      - aws/environments/*/tfplan
      - aws/environments/*/plan-readable.txt
    expire_in: 7 days

dev-approve:
  extends: .approve
  variables:
    ENV_DIR: dev-app-account
  needs:
    - job: dev-plan
      artifacts: true
  dependencies:
    - dev-plan

dev-apply:
  extends: .apply
  variables:
    ENV_DIR: dev-app-account
    DEPLOY_ROLE_ARN: $DEV_DEPLOY_ROLE_ARN
  environment:
    name: dev-app-account
    action: start
  needs:
    - job: dev-plan
      artifacts: true
    - job: dev-approve
      artifacts: true
  dependencies:
    - dev-plan

# Prod Account Jobs - Uses role assumption
prod-plan:
  extends: .assume_deploy_role
  stage: plan
  variables:
    ENV_DIR: prod-app-account
    DEPLOY_ROLE_ARN: $PROD_DEPLOY_ROLE_ARN
  script:
    - terraform plan -out=tfplan | tee plan.txt
    - terraform show -no-color tfplan > plan-readable.txt
  after_script:
    - |
      if [ "$CI_PIPELINE_SOURCE" == "merge_request_event" ] && [ -n "$GITLAB_TOKEN" ]; then
        cd ${TF_ROOT}/${ENV_DIR}
        PLAN_SUMMARY=$(cat plan-readable.txt | head -100)
        curl --request POST \
          --header "PRIVATE-TOKEN: $GITLAB_TOKEN" \
          --data "body=### Terraform Plan: ${ENV_DIR}\n\`\`\`\n${PLAN_SUMMARY}\n\`\`\`" \
          "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/merge_requests/${CI_MERGE_REQUEST_IID}/notes" || true
      fi
  artifacts:
    paths:
      - aws/environments/*/tfplan
      - aws/environments/*/plan-readable.txt
    expire_in: 7 days

prod-approve:
  extends: .approve
  variables:
    ENV_DIR: prod-app-account
  needs:
    - job: prod-plan
      artifacts: true
  dependencies:
    - prod-plan

prod-apply:
  extends: .apply
  variables:
    ENV_DIR: prod-app-account
    DEPLOY_ROLE_ARN: $PROD_DEPLOY_ROLE_ARN
  environment:
    name: prod-app-account
    action: start
  needs:
    - job: prod-plan
      artifacts: true
    - job: prod-approve
      artifacts: true
  dependencies:
    - prod-plan
